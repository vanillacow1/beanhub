<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bean's Cozy Hub</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Pacifico&family=Roboto:wght@400;500&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --cream: #fef6e4;
        --sage: #c7d5b8;
        --lavender: #d8c6f2;
        --rose: #f4d1d1;
        --butter: #fff4b1;
        --shadow: rgba(0, 0, 0, 0.12);
        --radius: 16px;
        --transition: 0.25s ease;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: "Roboto", sans-serif;
        background: linear-gradient(160deg, #fef6e4 0%, #d8c6f2 100%);
        color: #333;
        min-height: 100vh;
        overflow-y: scroll;
        padding: 0;
      }

      header {
        text-align: center;
        padding: 1.5rem 1rem 1rem;
        background: rgba(255, 255, 255, 0.85);
        backdrop-filter: blur(10px);
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
      }

      header h1 {
        font-family: "Pacifico", cursive;
        font-size: 1.8rem;
        color: #6b5b95;
      }

      .love-note {
        font-size: 0.9rem;
        color: #666;
        font-style: italic;
        margin-top: 0.2rem;
      }

      main {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        padding: 0 1rem 2rem;
      }

      section.card {
        backdrop-filter: blur(6px);
        background: rgba(255, 255, 255, 0.75);
        border-radius: var(--radius);
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.8rem;
        box-shadow: 0 6px 18px var(--shadow);
        transition: transform var(--transition), box-shadow var(--transition);
      }

      section.card:hover {
        transform: translateY(-3px);
        box-shadow: 0 10px 25px var(--shadow);
      }

      section.card h2 {
        font-family: "Pacifico", cursive;
        font-size: 1.3rem;
        color: #444;
        margin-bottom: 0.5rem;
      }

      .horizontal-scroll {
        display: flex;
        gap: 1rem;
        overflow-x: auto;
        padding-bottom: 0.5rem;
        scroll-behavior: smooth;
      }

      .horizontal-scroll::-webkit-scrollbar {
        height: 6px;
      }
      .horizontal-scroll::-webkit-scrollbar-thumb {
        background: var(--sage);
        border-radius: 3px;
      }

      .card-item {
        min-width: 180px;
        background: linear-gradient(135deg, #f4d1d1, #d8c6f2);
        border-radius: var(--radius);
        padding: 0.8rem;
        flex-shrink: 0;
        box-shadow: 0 4px 12px var(--shadow);
        transition: transform var(--transition), box-shadow var(--transition);
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
      }

      .card-item:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 20px var(--shadow);
      }

      .card-item img {
        width: 100%;
        border-radius: var(--radius);
        margin-bottom: 0.5rem;
      }

      .card-item p {
        font-size: 0.9rem;
        font-weight: 500;
        color: #333;
        line-height: 1.2rem;
        margin-bottom: 0.3rem;
      }

      /* Music Hub Layout */
      .music-sections {
        display: flex;
        gap: 1rem;
        overflow-x: auto;
        padding-bottom: 0.5rem;
        scroll-behavior: smooth;
      }

      .music-section {
        min-width: 280px;
        flex-shrink: 0;
        background: rgba(255, 255, 255, 0.5);
        border-radius: var(--radius);
        padding: 1rem;
        box-shadow: 0 4px 12px var(--shadow);
      }

      .music-section h3 {
        font-family: "Pacifico", cursive;
        font-size: 1.1rem;
        color: #444;
        margin-bottom: 0.8rem;
        text-align: center;
      }

      /* Now Playing Card */
      .now-playing-card {
        border-radius: var(--radius);
        padding: 1rem;
        margin-bottom: 1rem;
        color: white;
        display: block;
        transition: background 0.3s ease, box-shadow 0.3s ease;
        /* Always maintain the same size */
        min-height: 80px;
      }

      .now-playing-card.inactive {
        background: linear-gradient(135deg, #888, #aaa);
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.2);
      }

      .now-playing-card.active {
        background: linear-gradient(135deg, #1db954, #1ed760);
        box-shadow: 0 6px 18px rgba(29, 185, 84, 0.3);
      }

      .now-playing-content {
        display: flex;
        align-items: center;
        gap: 0.8rem;
        min-height: 48px; /* Consistent height */
      }

      .now-playing-art {
        width: 48px;
        height: 48px;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.2);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        flex-shrink: 0;
        overflow: hidden;
      }
      <!--
        Feedback
        Controls
        --
        > <div
        class="feedback-bar"
        id="feedbackBar"
        hidden
        > <div
        class="feedback-buttons"
        > <button
        class="feedback-btn"
        id="likeBtn"
        aria-label="Like"
        > üëç</button
        > <button
        class="feedback-btn"
        id="dislikeBtn"
        aria-label="Dislike"
        > üëé</button
        > </div
        > <div
        class="feedback-comment"
        > <textarea
        id="feedbackComment"
        placeholder="Leave a quick note about this track..."
        > </textarea
        > <button
        class="feedback-save-btn"
        id="feedbackSaveBtn"
        aria-label="Save comment"
        > üíæ
        Save</button
        > </div
        > <div
        class="feedback-status"
        id="feedbackStatus"
        role="status"
        aria-live="polite"
        > </div
        > </div
        > .now-playing-art
        img {
        width: 100%;
        height: 100%;
        border-radius: 8px;
        object-fit: cover;
      }

      .now-playing-info {
        flex: 1;
        min-width: 0;
      }

      .now-playing-track {
        font-weight: 600;
        font-size: 0.9rem;
        margin-bottom: 0.2rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .now-playing-artist {
        font-size: 0.8rem;
        opacity: 0.9;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .global-controls {
        display: flex;
        gap: 0.4rem;
        align-items: center;
      }

      .control-btn {
        background: rgba(255, 255, 255, 0.2);
        border: none;
        border-radius: 50%;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        color: white;
        font-size: 0.8rem;
      }

      .control-btn:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: scale(1.1);
      }

      .control-btn.primary {
        background: rgba(255, 255, 255, 0.9);
        color: #1db954;
        width: 36px;
        height: 36px;
        font-size: 0.9rem;
      }

      /* Songs Lists */
      #recentSongs,
      #suggestedSongs,
      #playlistSongs {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        max-height: 240px;
        overflow-y: auto;
        padding-right: 0.5rem;
      }

      #recentSongs::-webkit-scrollbar,
      #suggestedSongs::-webkit-scrollbar,
      #playlistSongs::-webkit-scrollbar {
        width: 4px;
      }

      #recentSongs::-webkit-scrollbar-thumb,
      #suggestedSongs::-webkit-scrollbar-thumb,
      #playlistSongs::-webkit-scrollbar-thumb {
        background: var(--sage);
        border-radius: 2px;
      }

      /* Playlists Section */
      .playlist-grid {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        max-height: 200px;
        overflow-y: auto;
        padding-right: 0.5rem;
        margin-bottom: 0.8rem;
      }

      .playlist-item {
        display: flex;
        align-items: center;
        gap: 0.6rem;
        background: rgba(255, 255, 255, 0.8);
        padding: 0.5rem;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      }

      .playlist-item:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
        background: rgba(255, 255, 255, 0.9);
      }

      .playlist-item.selected {
        background: linear-gradient(
          135deg,
          rgba(29, 185, 84, 0.2),
          rgba(30, 215, 96, 0.2)
        );
        border: 1px solid rgba(29, 185, 84, 0.3);
      }

      .playlist-art {
        width: 40px;
        height: 40px;
        border-radius: 6px;
        background: linear-gradient(135deg, #1db954, #1ed760);
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 0.8rem;
      }

      .playlist-art img {
        width: 100%;
        height: 100%;
        border-radius: 6px;
      }

      .playlist-info {
        flex: 1;
        min-width: 0;
      }

      .playlist-name {
        font-weight: 500;
        font-size: 0.8rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        margin-bottom: 0.1rem;
      }

      .playlist-count {
        font-size: 0.7rem;
        color: #666;
      }

      .song-row {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        background: rgba(255, 255, 255, 0.8);
        padding: 0.4rem 0.6rem;
        border-radius: 12px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        cursor: pointer;
      }

      .song-row:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
      }

      .song-row.playing {
        background: linear-gradient(
          135deg,
          rgba(29, 185, 84, 0.2),
          rgba(30, 215, 96, 0.2)
        );
        border: 1px solid rgba(29, 185, 84, 0.3);
      }

      .song-row img {
        width: 40px;
        height: 40px;
        border-radius: 8px;
      }

      .song-info {
        flex: 1;
        font-size: 0.8rem;
        line-height: 1rem;
      }

      .song-info .track-name {
        font-weight: 500;
        display: -webkit-box;
        -webkit-line-clamp: 1;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }

      .song-info .artist-name {
        color: #555;
        display: -webkit-box;
        -webkit-line-clamp: 1;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }

      .play-controls {
        display: flex;
        align-items: center;
        gap: 0.3rem;
      }

      .play-btn {
        background: linear-gradient(135deg, #1db954, #1ed760);
        border: none;
        border-radius: 50%;
        width: 28px;
        height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        color: white;
        font-size: 0.7rem;
      }

      .play-btn:hover {
        transform: scale(1.1);
        box-shadow: 0 2px 8px rgba(29, 185, 84, 0.4);
      }

      .spotify-link {
        color: #1db954;
        text-decoration: none;
        font-size: 0.8rem;
        opacity: 0.7;
        transition: opacity 0.2s ease;
      }

      .spotify-link:hover {
        opacity: 1;
      }

      button {
        background: linear-gradient(135deg, var(--lavender), var(--rose));
        border: none;
        padding: 0.6rem 1.2rem;
        border-radius: 999px;
        cursor: pointer;
        font-weight: 500;
        color: #fff;
        transition: transform var(--transition), box-shadow var(--transition);
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 14px var(--shadow);
      }

      button:active {
        transform: scale(0.95);
        box-shadow: 0 3px 6px var(--shadow);
      }

      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }

      .button-connected {
        background: linear-gradient(135deg, var(--sage), #98b49a);
      }

      input[type="text"] {
        padding: 0.5rem 1rem;
        border-radius: var(--radius);
        border: 1px solid #ddd;
        flex: 1;
        margin-bottom: 0.5rem;
      }

      .status-message {
        font-size: 0.85rem;
        padding: 0.5rem;
        border-radius: 8px;
        text-align: center;
        margin-bottom: 0.5rem;
        display: none;
      }

      .status-success {
        background: rgba(199, 213, 184, 0.3);
        color: #4a5c3a;
      }

      .status-error {
        background: rgba(244, 209, 209, 0.5);
        color: #8b4513;
      }

      .status-info {
        background: rgba(216, 198, 242, 0.3);
        color: #6b5b95;
      }

      @media (max-width: 600px) {
        header h1 {
          font-size: 1.6rem;
        }
        .card-item {
          min-width: 150px;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Good morning, Bean üåû</h1>
      <div class="love-note" id="loveNote">You're amazing, always üíõ</div>
    </header>

    <main>
      <!-- üéµ Music Hub -->
      <section class="card" id="musicHub">
        <h2>üéµ Music Hub</h2>
        <div id="statusMessage" class="status-message"></div>
        <div id="songOfDay">Click "Connect Spotify" to see your music!</div>

        <!-- Now Playing Card -->
        <div class="now-playing-card inactive" id="nowPlayingCard">
          <div class="now-playing-content">
            <div class="now-playing-art" id="nowPlayingArt">üéµ</div>
            <div class="now-playing-info">
              <div class="now-playing-track" id="nowPlayingTrack">
                Ready to Play
              </div>
              <div class="now-playing-artist" id="nowPlayingArtist">
                Select a song from below
              </div>
            </div>
            <div class="global-controls">
              <button class="control-btn" id="prevBtn" title="Previous">
                ‚èÆ
              </button>
              <button
                class="control-btn primary"
                id="globalPlayBtn"
                title="Play/Pause"
              >
                ‚ñ∂
              </button>
              <button class="control-btn" id="nextBtn" title="Next">‚è≠</button>
            </div>
          </div>
        </div>

        <div class="music-sections">
          <div class="music-section">
            <h3>üïí Your Recent Tracks</h3>
            <div id="recentSongs"></div>
          </div>

          <div class="music-section">
            <h3>üíé Your Top Favorites</h3>
            <div id="suggestedSongs"></div>
          </div>

          <div class="music-section">
            <h3>üìã Your Playlists</h3>
            <div class="playlist-grid" id="playlistGrid"></div>
            <div id="playlistSongs"></div>
          </div>
        </div>

        <button id="connectSpotifyBtn">Connect Spotify</button>
      </section>

      <!-- üì∫ Favorite Creators -->
      <section class="card" id="creatorsHub">
        <h2>üì∫ Favorite Creators</h2>
        <div class="horizontal-scroll" id="creatorCards"></div>
        <button id="watchLaterBtn">Add to Watch Later</button>
      </section>

      <!-- üß∂ Knitting Hub -->
      <section class="card" id="knittingHub">
        <h2>üß∂ Knitting Hub</h2>
        <div id="trendingPosts">Trending posts loading...</div>
        <button id="randomPatternBtn">Random Pattern Suggestion</button>
        <div class="horizontal-scroll" id="yarnShopDeals"></div>
      </section>

      <!-- üé¨ Movies & Shows -->
      <section class="card" id="moviesHub">
        <h2>üé¨ Movies & Shows</h2>
        <div class="horizontal-scroll" id="movieCards"></div>
        <button id="randomPickBtn">Random Pick</button>
      </section>

      <!-- üç≤ Recipe Section -->
      <section class="card" id="recipesHub">
        <h2>üç≤ Recipes</h2>
        <div class="horizontal-scroll" id="recipeCards"></div>
        <button id="randomRecipeBtn">Random Recipe</button>
      </section>

      <!-- üå± Plant Hub -->
      <section class="card" id="plantHub">
        <h2>üå± Plant Hub</h2>
        <input type="text" placeholder="Search for a plant" id="plantSearch" />
        <button id="addPlantBtn">Add Plant</button>
        <div id="needsWatering">Plants needing water today...</div>
        <div class="horizontal-scroll" id="plantCards"></div>
      </section>

      <!-- üå§Ô∏è Cozy Extras -->
      <section class="card" id="cozyExtras">
        <h2>üå§Ô∏è Cozy Extras</h2>
        <div id="weatherWidget">Weather loading...</div>
        <button id="surpriseMeBtn">Surprise Me üåü</button>
        <div id="memoryScrapbook">Memory scrapbook content here...</div>
      </section>
    </main>

    <script src="https://sdk.scdn.co/spotify-player.js"></script>
    <script>
      console.log("Script starting...");

      // State management
      let spotifyState = {
        isConnected: false,
        accessToken: null,
        refreshToken: null,
        expiresAt: null,
        userName: null,
      };

      // Music player state
      let currentAudio = null;
      let currentPlayingRow = null;
      let currentTrack = null;
      let allTracks = [];
      let currentTrackIndex = -1;
      let spotifyPlayer = null;
      let deviceId = null;
      let isSpotifySDKReady = false;

      const loveNotes = [
        "You brighten my day üíõ",
        "You're the best, Bean üå∏",
        "Love you endlessly üíï",
        "You're magical, truly ‚ú®",
      ];

      let noteIndex = 0;
      setInterval(() => {
        noteIndex = (noteIndex + 1) % loveNotes.length;
        const noteEl = document.getElementById("loveNote");
        if (noteEl) {
          noteEl.textContent = loveNotes[noteIndex];
        }
      }, 7000);

      function showStatus(message, type = "info") {
        console.log("Status:", message, type);
        const statusEl = document.getElementById("statusMessage");
        if (statusEl) {
          statusEl.textContent = message;
          statusEl.className = `status-message status-${type}`;
          statusEl.style.display = "block";

          if (type !== "error") {
            setTimeout(() => {
              statusEl.style.display = "none";
            }, 5000);
          }
        }
      }

      function updateSpotifyButton() {
        const btn = document.getElementById("connectSpotifyBtn");
        if (btn) {
          if (spotifyState.isConnected && spotifyState.userName) {
            btn.textContent = `Connected as ${spotifyState.userName}`;
            btn.classList.add("button-connected");
            btn.disabled = false;
          } else {
            btn.textContent = "Connect Spotify";
            btn.classList.remove("button-connected");
            btn.disabled = false;
          }
        }
      }

      const clientId = "10d85455cc3e4867adaa99146642e31f";
      const redirectUri = window.location.origin + window.location.pathname;
      const scopes =
        "user-read-private user-read-recently-played user-top-read streaming user-read-playback-state user-modify-playback-state playlist-read-private playlist-read-collaborative user-read-email";

      function generateCodeVerifier(length = 128) {
        const chars =
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
        let result = "";
        const array = new Uint32Array(length);
        window.crypto.getRandomValues(array);
        for (let i = 0; i < length; i++)
          result += chars[array[i] % chars.length];
        return result;
      }

      async function generateCodeChallenge(verifier) {
        const data = new TextEncoder().encode(verifier);
        const digest = await crypto.subtle.digest("SHA-256", data);
        return btoa(String.fromCharCode(...new Uint8Array(digest)))
          .replace(/\+/g, "-")
          .replace(/\//g, "_")
          .replace(/=+$/, "");
      }

      // Now Playing Card Functions
      function updateNowPlayingCard(track, isPlaying = false) {
        const nowPlayingCard = document.getElementById("nowPlayingCard");
        const nowPlayingArt = document.getElementById("nowPlayingArt");
        const nowPlayingTrack = document.getElementById("nowPlayingTrack");
        const nowPlayingArtist = document.getElementById("nowPlayingArtist");
        const globalPlayBtn = document.getElementById("globalPlayBtn");

        if (!track) {
          // Reset to default inactive state - only change colors and content
          nowPlayingCard.classList.remove("active");
          nowPlayingCard.classList.add("inactive");
          nowPlayingTrack.textContent = "Ready to Play";
          nowPlayingArtist.textContent = "Select a song from below";
          nowPlayingArt.innerHTML = "üéµ";
          if (globalPlayBtn) globalPlayBtn.textContent = "‚ñ∂";
          return;
        }

        // Active state with track playing - only change colors and content
        nowPlayingCard.classList.remove("inactive");
        nowPlayingCard.classList.add("active");
        nowPlayingTrack.textContent = track.name || "Unknown Track";
        nowPlayingArtist.textContent =
          track.artists?.[0]?.name || track.artist || "Unknown Artist";
        if (globalPlayBtn) globalPlayBtn.textContent = isPlaying ? "‚è∏" : "‚ñ∂";

        // Update album art - maintain consistent size
        const albumImage =
          track.album?.images?.[0]?.url || track.images?.[0]?.url;
        if (albumImage) {
          nowPlayingArt.innerHTML = `<img src="${albumImage}" alt="${track.name}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px;">`;
        } else {
          nowPlayingArt.innerHTML = "üéµ";
        }
      }

      async function toggleGlobalPlay() {
        try {
          if (spotifyPlayer && isSpotifySDKReady) {
            const state = await spotifyPlayer.getCurrentState();

            if (state) {
              // There's a current track - toggle play/pause
              if (state.paused) {
                await spotifyPlayer.resume();
                console.log("Resumed playback");
              } else {
                await spotifyPlayer.pause();
                console.log("Paused playback");
              }
            } else {
              // No current track - start playing the first track
              if (allTracks.length > 0) {
                console.log(
                  "Starting playback. Available tracks:",
                  allTracks.length
                );
                const firstTrack = allTracks[0];
                const firstSongRow = findSongRowForTrack(firstTrack);
                const trackUri =
                  firstTrack.uri || `spotify:track:${firstTrack.id}`;

                if (firstSongRow && trackUri) {
                  console.log("Playing first track:", firstTrack.name);
                  playSpotifyTrack(
                    trackUri,
                    firstTrack.name,
                    firstTrack.artists?.[0]?.name || firstTrack.artist,
                    firstSongRow
                  );
                }
              }
            }
          } else {
            // Fallback to preview system
            if (!currentAudio) {
              if (allTracks.length > 0) {
                console.log(
                  "Starting preview playback. Available tracks:",
                  allTracks.length
                );
                const firstTrack = allTracks[0];
                const firstSongRow = findSongRowForTrack(firstTrack);
                if (firstSongRow && firstTrack.preview_url) {
                  console.log("Playing first track preview:", firstTrack.name);
                  playPreviewFallback(
                    firstTrack.preview_url,
                    firstTrack.name,
                    firstTrack.artists?.[0]?.name || firstTrack.artist,
                    firstSongRow
                  );
                }
              }
              return;
            }

            if (currentAudio.paused) {
              currentAudio.play();
              updatePlayButtonStates(true);
            } else {
              currentAudio.pause();
              updatePlayButtonStates(false);
            }
          }
        } catch (error) {
          console.error("Error toggling playback:", error);
          showStatus("Playback control error", "error");
        }
      }

      async function playNext() {
        if (allTracks.length === 0) return;

        let nextIndex = currentTrackIndex + 1;
        if (nextIndex >= allTracks.length) {
          nextIndex = 0; // Loop back to start
        }

        const nextTrack = allTracks[nextIndex];
        if (nextTrack) {
          // Try to find the song row, but don't require it for playback
          const matchingSongRow = findSongRowForTrack(nextTrack);
          const trackUri = nextTrack.uri || `spotify:track:${nextTrack.id}`;

          if (trackUri && nextTrack.id && isSpotifySDKReady) {
            // Play without requiring a DOM element
            playSpotifyTrack(
              trackUri,
              nextTrack.name,
              nextTrack.artists?.[0]?.name || nextTrack.artist,
              matchingSongRow // Can be null if playlist is minimized
            );
          } else if (nextTrack.preview_url) {
            playPreviewFallback(
              nextTrack.preview_url,
              nextTrack.name,
              nextTrack.artists?.[0]?.name || nextTrack.artist,
              matchingSongRow // Can be null if playlist is minimized
            );
          }
        }
      }

      async function playPrevious() {
        if (allTracks.length === 0) return;

        let prevIndex = currentTrackIndex - 1;
        if (prevIndex < 0) {
          prevIndex = allTracks.length - 1; // Loop to end
        }

        const prevTrack = allTracks[prevIndex];
        if (prevTrack) {
          // Try to find the song row, but don't require it for playback
          const matchingSongRow = findSongRowForTrack(prevTrack);
          const trackUri = prevTrack.uri || `spotify:track:${prevTrack.id}`;

          if (trackUri && prevTrack.id && isSpotifySDKReady) {
            // Play without requiring a DOM element
            playSpotifyTrack(
              trackUri,
              prevTrack.name,
              prevTrack.artists?.[0]?.name || prevTrack.artist,
              matchingSongRow // Can be null if playlist is minimized
            );
          } else if (prevTrack.preview_url) {
            playPreviewFallback(
              prevTrack.preview_url,
              prevTrack.name,
              prevTrack.artists?.[0]?.name || prevTrack.artist,
              matchingSongRow // Can be null if playlist is minimized
            );
          }
        }
      }

      // Helper function to find a song row that matches a track
      function findSongRowForTrack(track) {
        const allSongRows = document.querySelectorAll(".song-row");
        const trackName = track.name;
        const artistName = track.artists?.[0]?.name || track.artist;

        for (let row of allSongRows) {
          const rowTrackName = row.querySelector(".track-name")?.textContent;
          const rowArtistName = row.querySelector(".artist-name")?.textContent;

          if (rowTrackName === trackName && rowArtistName === artistName) {
            return row;
          }
        }
        return null;
      }

      // Initialize Spotify Web Playback SDK
      window.onSpotifyWebPlaybackSDKReady = () => {
        console.log("Spotify Web Playback SDK is ready");
        if (spotifyState.accessToken) {
          initializeSpotifyPlayer();
        }
      };

      async function initializeSpotifyPlayer() {
        if (spotifyPlayer) {
          console.log("Spotify player already initialized");
          return;
        }

        try {
          console.log("Initializing Spotify Web Player...");

          const player = new Spotify.Player({
            name: "Bean's Cozy Hub Player",
            getOAuthToken: (cb) => {
              console.log("Getting OAuth token for player");
              cb(spotifyState.accessToken);
            },
            volume: 0.8,
          });

          // Error handling
          player.addListener("initialization_error", ({ message }) => {
            console.error("Spotify Player initialization error:", message);
            showStatus(
              "Failed to initialize Spotify player: " + message,
              "error"
            );
          });

          player.addListener("authentication_error", ({ message }) => {
            console.error("Spotify Player authentication error:", message);
            showStatus("Spotify authentication error: " + message, "error");
          });

          player.addListener("account_error", ({ message }) => {
            console.error("Spotify Player account error:", message);
            showStatus("Spotify Premium required for full playback", "error");
          });

          player.addListener("playback_error", ({ message }) => {
            console.error("Spotify Player playback error:", message);
            showStatus("Playback error: " + message, "error");
          });

          // Ready
          player.addListener("ready", ({ device_id }) => {
            console.log("Spotify Player ready with Device ID:", device_id);
            deviceId = device_id;
            isSpotifySDKReady = true;
            showStatus(
              "Spotify player ready! You can now play full songs.",
              "success"
            );
          });

          // Not Ready
          player.addListener("not_ready", ({ device_id }) => {
            console.log("Spotify Player device has gone offline:", device_id);
            isSpotifySDKReady = false;
          });

          // Player state changes
          player.addListener("player_state_changed", (state) => {
            if (!state) return;

            console.log("Player state changed:", state);

            const track = state.track_window.current_track;
            const isPlaying = !state.paused;

            if (track) {
              // Update current track info
              currentTrack = {
                name: track.name,
                artists: track.artists,
                album: { images: [{ url: track.album.images[0]?.url }] },
                id: track.id,
                uri: track.uri,
              };

              // Update UI
              updateNowPlayingCard(currentTrack, isPlaying);
              updatePlayButtonStates(isPlaying);

              // Find and highlight the current playing row
              const songRow = findSongRowForTrack(currentTrack);
              if (songRow) {
                // Remove playing state from all rows
                document.querySelectorAll(".song-row").forEach((row) => {
                  row.classList.remove("playing");
                  const playBtn = row.querySelector(".play-btn");
                  if (playBtn) playBtn.textContent = "‚ñ∂";
                });

                // Add playing state to current row
                if (isPlaying) {
                  songRow.classList.add("playing");
                  const playBtn = songRow.querySelector(".play-btn");
                  if (playBtn) playBtn.textContent = "‚è∏";
                }

                currentPlayingRow = songRow;
              }
            }
          });

          // Connect to the player!
          const connected = await player.connect();
          if (connected) {
            console.log("Successfully connected to Spotify Player");
            spotifyPlayer = player;
          } else {
            console.error("Failed to connect to Spotify Player");
            showStatus("Failed to connect to Spotify player", "error");
          }
        } catch (error) {
          console.error("Error initializing Spotify player:", error);
          showStatus(
            "Error setting up Spotify player: " + error.message,
            "error"
          );
        }
      }

      function updatePlayButtonStates(isPlaying) {
        const globalPlayBtn = document.getElementById("globalPlayBtn");
        if (globalPlayBtn) {
          globalPlayBtn.textContent = isPlaying ? "‚è∏" : "‚ñ∂";
        }
      }

      async function playSpotifyTrack(
        trackUri,
        trackName,
        artistName,
        songRow
      ) {
        if (!isSpotifySDKReady || !deviceId) {
          console.log("Spotify SDK not ready, falling back to preview");
          playPreviewFallback(trackUri, trackName, artistName, songRow);
          return;
        }

        try {
          // Find track in allTracks array and update currentTrack
          const trackData = allTracks.find(
            (t) =>
              t.name === trackName &&
              (t.artists?.[0]?.name || t.artist) === artistName
          );
          currentTrackIndex = trackData ? allTracks.indexOf(trackData) : -1;

          // Check if clicking the same song that's playing (only if songRow exists)
          if (songRow && currentPlayingRow === songRow && spotifyPlayer) {
            const state = await spotifyPlayer.getCurrentState();
            if (state && !state.paused) {
              // Pause the current track
              await spotifyPlayer.pause();
              return;
            } else if (state && state.paused) {
              // Resume the current track
              await spotifyPlayer.resume();
              return;
            }
          }

          console.log("Playing Spotify track:", trackName, "by", artistName);
          console.log("Track URI:", trackUri);

          // Play the track using Spotify Web API
          const playResponse = await fetch(
            `https://api.spotify.com/v1/me/player/play?device_id=${deviceId}`,
            {
              method: "PUT",
              headers: {
                Authorization: "Bearer " + spotifyState.accessToken,
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                uris: [trackUri],
              }),
            }
          );

          if (playResponse.ok || playResponse.status === 204) {
            console.log("Successfully started playback");
            showStatus(`Playing: ${trackName}`, "success");

            // Update UI immediately (the player state listener will also update it)
            currentPlayingRow = songRow;

            // Remove playing state from all other rows
            document.querySelectorAll(".song-row").forEach((row) => {
              if (row !== songRow) {
                row.classList.remove("playing");
                const playBtn = row.querySelector(".play-btn");
                if (playBtn) playBtn.textContent = "‚ñ∂";
              }
            });

            // Add playing state to current row (only if songRow exists)
            if (songRow) {
              songRow.classList.add("playing");
              const playBtn = songRow.querySelector(".play-btn");
              if (playBtn) playBtn.textContent = "‚è∏";
            }
          } else {
            const errorData = await playResponse.text();
            console.error("Playback failed:", playResponse.status, errorData);

            if (playResponse.status === 404) {
              showStatus(
                "Device not found. Please refresh and try again.",
                "error"
              );
            } else if (playResponse.status === 403) {
              showStatus("Spotify Premium required for full playback", "error");
            } else {
              showStatus("Playback failed. Trying preview instead.", "error");
              // Fallback to preview
              const track = allTracks.find((t) => t.name === trackName);
              if (track && track.preview_url) {
                playPreviewFallback(
                  track.preview_url,
                  trackName,
                  artistName,
                  songRow
                );
              }
            }
          }
        } catch (error) {
          console.error("Error playing Spotify track:", error);
          showStatus("Playback error. Trying preview instead.", "error");

          // Fallback to preview
          const track = allTracks.find((t) => t.name === trackName);
          if (track && track.preview_url) {
            playPreviewFallback(
              track.preview_url,
              trackName,
              artistName,
              songRow
            );
          }
        }
      }

      function playPreviewFallback(previewUrl, trackName, artistName, songRow) {
        // Stop current audio if playing
        if (currentAudio) {
          currentAudio.pause();
          if (currentPlayingRow) {
            currentPlayingRow.classList.remove("playing");
            const playBtn = currentPlayingRow.querySelector(".play-btn");
            if (playBtn) playBtn.textContent = "‚ñ∂";
          }
        }

        if (!previewUrl) {
          showStatus("No preview available for this track", "info");
          return;
        }

        // If clicking the same song that's playing, just stop (only if songRow exists)
        if (
          songRow &&
          currentPlayingRow === songRow &&
          currentAudio &&
          !currentAudio.paused
        ) {
          currentAudio.pause();
          songRow.classList.remove("playing");
          const playBtn = songRow.querySelector(".play-btn");
          if (playBtn) playBtn.textContent = "‚ñ∂";
          currentPlayingRow = null;
          currentAudio = null;
          currentTrack = null;
          updateNowPlayingCard(null);
          return;
        }

        // Create and play new audio
        currentAudio = new Audio(previewUrl);
        currentPlayingRow = songRow;

        // Find track in allTracks array and update currentTrack
        const trackData = allTracks.find(
          (t) =>
            t.name === trackName &&
            (t.artists?.[0]?.name || t.artist) === artistName
        );
        currentTrack = trackData || {
          name: trackName,
          artist: artistName,
          artists: [{ name: artistName }],
          preview_url: previewUrl,
        };
        currentTrackIndex = trackData ? allTracks.indexOf(trackData) : -1;

        // Add playing state only if songRow exists
        if (songRow) {
          songRow.classList.add("playing");
          const playBtn = songRow.querySelector(".play-btn");
          if (playBtn) playBtn.textContent = "‚è∏";
        }

        // Update now playing card
        updateNowPlayingCard(currentTrack, true);

        currentAudio.play().catch((error) => {
          console.error("Playback failed:", error);
          showStatus("Playback failed. Try again!", "error");
          if (songRow) {
            songRow.classList.remove("playing");
            const playBtn = songRow.querySelector(".play-btn");
            if (playBtn) playBtn.textContent = "‚ñ∂";
          }
          updateNowPlayingCard(null);
        });

        currentAudio.onended = () => {
          if (songRow) {
            songRow.classList.remove("playing");
            const playBtn = songRow.querySelector(".play-btn");
            if (playBtn) playBtn.textContent = "‚ñ∂";
          }
          currentPlayingRow = null;
          currentAudio = null;
          updateNowPlayingCard(null);
          playNext();
        };
      }

      function createSongRow(track, container) {
        const div = document.createElement("div");
        div.className = "song-row";

        const previewUrl = track.preview_url;
        const hasPreview = !!previewUrl;

        div.innerHTML = `
          <img src="${
            track.album?.images?.[0]?.url ||
            track.images?.[0]?.url ||
            'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40"><rect width="40" height="40" fill="%23ddd"/><text x="20" y="24" text-anchor="middle" font-size="12" fill="%23999">‚ô™</text></svg>'
          }" alt="${track.name}">
          <div class="song-info">
            <p class="track-name">${track.name}</p>
            <p class="artist-name">${
              track.artists?.[0]?.name || track.artist || "Unknown Artist"
            }</p>
          </div>
          <div class="play-controls">
            ${hasPreview ? '<button class="play-btn">‚ñ∂</button>' : ""}
            <a href="https://open.spotify.com/track/${
              track.id || ""
            }" target="_blank" class="spotify-link" onclick="event.stopPropagation()">üéµ</a>
          </div>
        `;

        // Make the entire song row clickable (except for the Spotify link)
        div.addEventListener("click", (e) => {
          // Don't trigger if clicking the Spotify link
          if (e.target.classList.contains("spotify-link")) {
            return;
          }

          const trackUri = track.uri || `spotify:track:${track.id}`;
          console.log(
            "Playing track:",
            track.name,
            "by",
            track.artists?.[0]?.name || track.artist
          );

          if (trackUri && track.id) {
            playSpotifyTrack(
              trackUri,
              track.name,
              track.artists?.[0]?.name || track.artist,
              div
            );
          } else if (hasPreview) {
            playPreviewFallback(
              previewUrl,
              track.name,
              track.artists?.[0]?.name || track.artist,
              div
            );
          } else {
            showStatus("Track not available for playback", "info");
          }
        });

        // Still add the play button functionality for explicit play button clicks
        if (hasPreview) {
          const playBtn = div.querySelector(".play-btn");
          if (playBtn) {
            playBtn.addEventListener("click", (e) => {
              e.stopPropagation();
              console.log("Play button clicked for:", track.name);

              const trackUri = track.uri || `spotify:track:${track.id}`;
              if (trackUri && track.id) {
                playSpotifyTrack(
                  trackUri,
                  track.name,
                  track.artists?.[0]?.name || track.artist,
                  div
                );
              } else if (previewUrl) {
                playPreviewFallback(
                  previewUrl,
                  track.name,
                  track.artists?.[0]?.name || track.artist,
                  div
                );
              }
            });
          }
        }

        return div;
      }

      async function fetchUserPlaylists() {
        try {
          const playlistsRes = await fetch(
            "https://api.spotify.com/v1/me/playlists?limit=20",
            { headers: { Authorization: "Bearer " + spotifyState.accessToken } }
          );

          if (playlistsRes.ok) {
            const playlistsData = await playlistsRes.json();
            const playlists = playlistsData.items || [];

            const playlistGrid = document.getElementById("playlistGrid");
            if (playlistGrid) {
              playlistGrid.innerHTML = "";

              if (playlists.length > 0) {
                playlists.forEach((playlist) => {
                  const playlistItem = document.createElement("div");
                  playlistItem.className = "playlist-item";

                  playlistItem.innerHTML = `
                    <div class="playlist-art">
                      ${
                        playlist.images && playlist.images[0]
                          ? `<img src="${playlist.images[0].url}" alt="${playlist.name}">`
                          : "üìã"
                      }
                    </div>
                    <div class="playlist-info">
                      <div class="playlist-name">${playlist.name}</div>
                      <div class="playlist-count">${
                        playlist.tracks.total
                      } tracks</div>
                    </div>
                  `;

                  playlistItem.addEventListener("click", () => {
                    const playlistSongs =
                      document.getElementById("playlistSongs");
                    const isCurrentlySelected =
                      playlistItem.classList.contains("selected");

                    // Remove selection from all playlists
                    document
                      .querySelectorAll(".playlist-item")
                      .forEach((item) => {
                        item.classList.remove("selected");
                      });

                    if (isCurrentlySelected) {
                      // If clicking the same playlist, minimize it
                      if (playlistSongs) {
                        playlistSongs.innerHTML = "";
                        playlistSongs.style.display = "none";
                      }
                    } else {
                      // If clicking a different playlist, show it
                      playlistItem.classList.add("selected");
                      if (playlistSongs) {
                        playlistSongs.style.display = "flex";
                      }
                      fetchPlaylistTracks(playlist.id, playlist.name);
                    }
                  });

                  playlistGrid.appendChild(playlistItem);
                });
              } else {
                playlistGrid.innerHTML =
                  '<p style="text-align: center; color: #666; font-size: 0.8rem;">No playlists found</p>';
              }
            }
          }
        } catch (error) {
          console.error("Playlists error:", error);
          const playlistGrid = document.getElementById("playlistGrid");
          if (playlistGrid) {
            playlistGrid.innerHTML =
              '<p style="text-align: center; color: #666; font-size: 0.8rem;">Unable to load playlists</p>';
          }
        }
      }

      async function fetchPlaylistTracks(playlistId, playlistName) {
        try {
          const tracksRes = await fetch(
            `https://api.spotify.com/v1/playlists/${playlistId}/tracks?limit=20`,
            { headers: { Authorization: "Bearer " + spotifyState.accessToken } }
          );

          if (tracksRes.ok) {
            const tracksData = await tracksRes.json();
            const tracks =
              tracksData.items
                ?.map((item) => item.track)
                .filter((track) => track && track.id) || [];

            const playlistSongs = document.getElementById("playlistSongs");
            if (playlistSongs) {
              playlistSongs.innerHTML = "";

              if (tracks.length > 0) {
                // Add playlist tracks to allTracks array for global controls
                allTracks = [...allTracks, ...tracks];

                tracks.forEach((track) => {
                  const songRow = createSongRow(track, playlistSongs);
                  playlistSongs.appendChild(songRow);
                });
              } else {
                playlistSongs.innerHTML =
                  '<p style="text-align: center; color: #666; font-size: 0.8rem;">No tracks in this playlist</p>';
              }
            }
          }
        } catch (error) {
          console.error("Playlist tracks error:", error);
          const playlistSongs = document.getElementById("playlistSongs");
          if (playlistSongs) {
            playlistSongs.innerHTML =
              '<p style="text-align: center; color: #666; font-size: 0.8rem;">Unable to load tracks</p>';
          }
        }
      }

      async function loginSpotify() {
        console.log("loginSpotify called");
        try {
          showStatus("Connecting to Spotify...", "info");
          const btn = document.getElementById("connectSpotifyBtn");
          if (btn) {
            btn.disabled = true;
            btn.textContent = "Connecting...";
          }

          const verifier = generateCodeVerifier();
          sessionStorage.setItem("spotify_verifier", verifier);
          const challenge = await generateCodeChallenge(verifier);

          const url =
            `https://accounts.spotify.com/authorize?response_type=code&client_id=${clientId}` +
            `&scope=${encodeURIComponent(scopes)}` +
            `&redirect_uri=${encodeURIComponent(redirectUri)}` +
            `&code_challenge_method=S256&code_challenge=${challenge}`;

          console.log("Redirecting to:", url);
          window.location = url;
        } catch (error) {
          console.error("Login error:", error);
          showStatus(
            "Failed to connect to Spotify. Please try again.",
            "error"
          );
          updateSpotifyButton();
        }
      }

      async function handleSpotifyCallback() {
        const params = new URLSearchParams(window.location.search);
        const code = params.get("code");
        const error = params.get("error");

        if (error) {
          showStatus("Spotify connection was cancelled.", "error");
          window.history.replaceState({}, document.title, redirectUri);
          return;
        }

        if (!code) return;

        try {
          showStatus("Completing Spotify connection...", "info");
          const verifier = sessionStorage.getItem("spotify_verifier");

          if (!verifier) {
            throw new Error("Missing verification code");
          }

          const body = new URLSearchParams({
            grant_type: "authorization_code",
            code: code,
            redirect_uri: redirectUri,
            client_id: clientId,
            code_verifier: verifier,
          });

          const res = await fetch("https://accounts.spotify.com/api/token", {
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            body: body.toString(),
          });

          if (!res.ok) {
            const errorData = await res.json();
            throw new Error(
              `Token request failed: ${res.status} - ${
                errorData.error_description || errorData.error
              }`
            );
          }

          const data = await res.json();
          const expiresAt = Date.now() + data.expires_in * 1000;

          spotifyState.accessToken = data.access_token;
          spotifyState.refreshToken = data.refresh_token;
          spotifyState.expiresAt = expiresAt;
          spotifyState.isConnected = true;

          sessionStorage.setItem("spotify_access_token", data.access_token);
          if (data.refresh_token) {
            sessionStorage.setItem("spotify_refresh_token", data.refresh_token);
          }
          sessionStorage.setItem("spotify_expires_at", expiresAt.toString());

          // Get user info
          const userRes = await fetch("https://api.spotify.com/v1/me", {
            headers: { Authorization: "Bearer " + data.access_token },
          });

          if (userRes.ok) {
            const userData = await userRes.json();
            spotifyState.userName = userData.display_name || userData.id;
            sessionStorage.setItem("spotify_user_name", spotifyState.userName);
          }

          window.history.replaceState({}, document.title, redirectUri);
          showStatus(
            `Connected successfully! Welcome, ${
              spotifyState.userName || "Bean"
            }! üéµ`,
            "success"
          );
          updateSpotifyButton();
          await fetchRecommendedTracks();
          // Initialize Spotify player after successful authentication
          if (window.Spotify) {
            await initializeSpotifyPlayer();
          }
        } catch (error) {
          console.error("Callback error:", error);
          showStatus(
            `Failed to complete Spotify connection: ${error.message}`,
            "error"
          );
          window.history.replaceState({}, document.title, redirectUri);
        }
      }

      async function fetchRecommendedTracks() {
        if (!spotifyState.accessToken) {
          const songOfDay = document.getElementById("songOfDay");
          if (songOfDay) {
            songOfDay.textContent =
              "Click 'Connect Spotify' to see your music!";
          }
          return;
        }

        try {
          // Check if token expired
          if (Date.now() >= spotifyState.expiresAt) {
            showStatus("Spotify session expired. Please reconnect.", "error");
            clearStoredAuth();
            return;
          }

          // Fetch recent tracks
          const recentRes = await fetch(
            "https://api.spotify.com/v1/me/player/recently-played?limit=10",
            { headers: { Authorization: "Bearer " + spotifyState.accessToken } }
          );

          if (recentRes.status === 401) {
            showStatus("Spotify session expired. Please reconnect.", "error");
            clearStoredAuth();
            return;
          }

          if (recentRes.status === 403) {
            showStatus(
              "Account needs to be added to app allowlist. Ask your developer to add you!",
              "error"
            );
            showFallbackMusic();
            return;
          }

          let recentTracks = [];
          if (recentRes.ok) {
            const recentData = await recentRes.json();
            const allRecentTracks =
              recentData.items
                ?.map((item) => item.track)
                .filter((track) => track && track.id) || [];

            // Remove duplicates based on track ID
            const seenTrackIds = new Set();
            recentTracks = allRecentTracks.filter((track) => {
              if (seenTrackIds.has(track.id)) {
                return false; // Skip duplicate
              }
              seenTrackIds.add(track.id);
              return true; // Keep unique track
            });
          }

          // If no recently played, fallback to top tracks
          if (!recentTracks.length) {
            const topRes = await fetch(
              "https://api.spotify.com/v1/me/top/tracks?limit=10",
              {
                headers: {
                  Authorization: "Bearer " + spotifyState.accessToken,
                },
              }
            );

            if (topRes.status === 403) {
              showStatus(
                "Account needs to be added to app allowlist. Ask your developer to add you!",
                "error"
              );
              showFallbackMusic();
              return;
            }

            if (topRes.ok) {
              const topData = await topRes.json();
              recentTracks =
                topData.items?.filter((track) => track && track.id) || [];
            }
          }

          // Display recent tracks
          const recentContainer = document.getElementById("recentSongs");
          if (recentContainer) {
            recentContainer.innerHTML = "";

            if (recentTracks.length > 0) {
              // Update allTracks array for global controls
              allTracks = [...recentTracks.slice(0, 10)];

              recentTracks.slice(0, 10).forEach((track, index) => {
                const songRow = createSongRow(track, recentContainer);
                recentContainer.appendChild(songRow);

                if (index === 0) {
                  const songOfDay = document.getElementById("songOfDay");
                  if (songOfDay) {
                    songOfDay.textContent = `üéµ ${track.name} ‚Äì ${track.artists[0]?.name}`;
                  }
                }
              });
            } else {
              recentContainer.innerHTML =
                '<p style="text-align: center; color: #666; font-size: 0.8rem;">No recent tracks found</p>';
              allTracks = [];
              showFallbackMusic();
              return;
            }
          }

          // Fetch recommendations and playlists
          await Promise.all([
            fetchSpotifyRecommendations(recentTracks),
            fetchUserPlaylists(),
          ]);
        } catch (error) {
          console.error("Fetch tracks error:", error);
          showStatus(
            "Failed to load your music. Check your connection.",
            "error"
          );
          showFallbackMusic();
        }
      }

      async function fetchSpotifyRecommendations(seedTracks) {
        try {
          const suggestedContainer = document.getElementById("suggestedSongs");
          if (!suggestedContainer) return;

          if (!seedTracks.length) {
            suggestedContainer.innerHTML =
              '<p style="text-align: center; color: #666; font-size: 0.8rem;">No recent tracks for suggestions</p>';
            return;
          }

          // Try the recommendations endpoint first
          const seedTrackIds = seedTracks
            .slice(0, 3)
            .map((track) => track.id)
            .join(",");

          const recRes = await fetch(
            `https://api.spotify.com/v1/recommendations?seed_tracks=${seedTrackIds}&limit=10`,
            { headers: { Authorization: "Bearer " + spotifyState.accessToken } }
          );

          if (recRes.ok) {
            const recData = await recRes.json();
            const suggestions =
              recData.tracks?.filter((track) => track && track.id) || [];

            if (suggestions.length > 0) {
              suggestedContainer.innerHTML = "";
              // Add suggestions to allTracks array
              allTracks = [...allTracks, ...suggestions];

              suggestions.forEach((track) => {
                const songRow = createSongRow(track, suggestedContainer);
                suggestedContainer.appendChild(songRow);
              });
              return;
            }
          }

          // Fallback: Use user's top tracks as "suggestions"
          console.log(
            "Recommendations API not available, falling back to top tracks"
          );
          const topRes = await fetch(
            "https://api.spotify.com/v1/me/top/tracks?limit=10&time_range=medium_term",
            { headers: { Authorization: "Bearer " + spotifyState.accessToken } }
          );

          if (topRes.ok) {
            const topData = await topRes.json();
            const topTracks =
              topData.items?.filter((track) => track && track.id) || [];

            suggestedContainer.innerHTML = "";

            if (topTracks.length > 0) {
              // Filter out tracks that are already in recent tracks
              const recentTrackIds = seedTracks.map((t) => t.id);
              const filteredTracks = topTracks.filter(
                (track) => !recentTrackIds.includes(track.id)
              );

              if (filteredTracks.length > 0) {
                // Add to allTracks array
                allTracks = [...allTracks, ...filteredTracks.slice(0, 10)];

                filteredTracks.slice(0, 10).forEach((track) => {
                  const songRow = createSongRow(track, suggestedContainer);
                  suggestedContainer.appendChild(songRow);
                });
              } else {
                suggestedContainer.innerHTML =
                  '<p style="text-align: center; color: #666; font-size: 0.8rem;">All your top tracks are already in recent!</p>';
              }
            } else {
              suggestedContainer.innerHTML =
                '<p style="text-align: center; color: #666; font-size: 0.8rem;">Play more music to see suggestions!</p>';
            }
          } else {
            suggestedContainer.innerHTML =
              '<p style="text-align: center; color: #666; font-size: 0.8rem;">Suggestions unavailable</p>';
          }
        } catch (error) {
          console.error("Recommendations error:", error);
          const suggestedContainer = document.getElementById("suggestedSongs");
          if (suggestedContainer) {
            suggestedContainer.innerHTML =
              '<p style="text-align: center; color: #666; font-size: 0.8rem;">Unable to load suggestions</p>';
          }
        }
      }

      function showFallbackMusic() {
        const fallbackTracks = [
          {
            name: "Good 4 U",
            artist: "Olivia Rodrigo",
            spotifyId: "4ZtFanR9U6ndgddUvNcjcG",
            preview_url: null,
          },
          {
            name: "Anti-Hero",
            artist: "Taylor Swift",
            spotifyId: "0V3wPSX9ygBnCm8psDIegu",
            preview_url: null,
          },
          {
            name: "Flowers",
            artist: "Miley Cyrus",
            spotifyId: "0yLdNVWF3Srea0uzk55zFn",
            preview_url: null,
          },
          {
            name: "As It Was",
            artist: "Harry Styles",
            spotifyId: "4Dvkj6JhhA12EX05fT7y2e",
            preview_url: null,
          },
          {
            name: "Unholy",
            artist: "Sam Smith ft. Kim Petras",
            spotifyId: "3nqQXoyQOWXiESFLlDF1hG",
            preview_url: null,
          },
        ];

        const songOfDay = document.getElementById("songOfDay");
        if (songOfDay) {
          songOfDay.textContent = `üéµ ${fallbackTracks[0].name} ‚Äì ${fallbackTracks[0].artist} (Popular Track)`;
        }

        const recentContainer = document.getElementById("recentSongs");
        const suggestedContainer = document.getElementById("suggestedSongs");
        if (recentContainer) recentContainer.innerHTML = "";
        if (suggestedContainer) suggestedContainer.innerHTML = "";

        // Reset allTracks for fallback
        allTracks = [];

        fallbackTracks.forEach((track) => {
          const fakeTrack = {
            name: track.name,
            artist: track.artist,
            artists: [{ name: track.artist }],
            id: track.spotifyId,
            preview_url: track.preview_url,
            album: { images: [] },
          };

          allTracks.push(fakeTrack);

          if (recentContainer) {
            const songRow = createSongRow(fakeTrack, recentContainer);
            recentContainer.appendChild(songRow);
          }
        });

        if (suggestedContainer) {
          suggestedContainer.innerHTML =
            '<p style="text-align: center; color: #666; font-size: 0.8rem;">Connect Spotify for personalized suggestions!</p>';
        }

        // Clear playlists
        const playlistGrid = document.getElementById("playlistGrid");
        const playlistSongs = document.getElementById("playlistSongs");
        if (playlistGrid) {
          playlistGrid.innerHTML =
            '<p style="text-align: center; color: #666; font-size: 0.8rem;">Connect Spotify to see playlists!</p>';
        }
        if (playlistSongs) {
          playlistSongs.innerHTML = "";
        }
      }

      function clearStoredAuth() {
        sessionStorage.removeItem("spotify_access_token");
        sessionStorage.removeItem("spotify_refresh_token");
        sessionStorage.removeItem("spotify_expires_at");
        sessionStorage.removeItem("spotify_user_name");
        sessionStorage.removeItem("spotify_verifier");

        spotifyState = {
          isConnected: false,
          accessToken: null,
          refreshToken: null,
          expiresAt: null,
          userName: null,
        };
        updateSpotifyButton();
      }

      function checkStoredAuth() {
        const token = sessionStorage.getItem("spotify_access_token");
        const expiresAt = sessionStorage.getItem("spotify_expires_at");
        const userName = sessionStorage.getItem("spotify_user_name");

        if (token && expiresAt) {
          if (Date.now() < parseInt(expiresAt)) {
            spotifyState.accessToken = token;
            spotifyState.expiresAt = parseInt(expiresAt);
            spotifyState.userName = userName;
            spotifyState.isConnected = true;

            showStatus(`Welcome back, ${userName || "Bean"}! üéµ`, "success");
            updateSpotifyButton();
            fetchRecommendedTracks();
            // Initialize Spotify player if SDK is ready
            if (window.Spotify) {
              initializeSpotifyPlayer();
            }
          } else {
            showStatus("Spotify session expired. Please reconnect.", "error");
            clearStoredAuth();
          }
        }
      }

      function initializeApp() {
        console.log("Initializing app...");

        // Connect Spotify button
        const connectBtn = document.getElementById("connectSpotifyBtn");
        if (connectBtn) {
          console.log("Setting up connect button");
          connectBtn.addEventListener("click", (e) => {
            console.log("Connect button clicked!");
            e.preventDefault();
            if (spotifyState.isConnected) {
              if (confirm("Already connected! Want to refresh your music?")) {
                fetchRecommendedTracks();
              }
            } else {
              loginSpotify();
            }
          });
        }

        // Global control event listeners
        const globalPlayBtn = document.getElementById("globalPlayBtn");
        const prevBtn = document.getElementById("prevBtn");
        const nextBtn = document.getElementById("nextBtn");

        if (globalPlayBtn)
          globalPlayBtn.addEventListener("click", toggleGlobalPlay);
        if (prevBtn) prevBtn.addEventListener("click", playPrevious);
        if (nextBtn) nextBtn.addEventListener("click", playNext);

        // Other buttons
        const buttons = [
          { id: "watchLaterBtn", message: "Watch Later coming!" },
          { id: "randomPatternBtn", message: "Random Pattern coming!" },
          { id: "randomPickBtn", message: "Random Pick coming!" },
          { id: "randomRecipeBtn", message: "Random Recipe coming!" },
          { id: "addPlantBtn", message: "Add Plant coming!" },
          { id: "surpriseMeBtn", message: "Surprise content!" },
        ];

        buttons.forEach(({ id, message }) => {
          const btn = document.getElementById(id);
          if (btn) {
            btn.addEventListener("click", () => alert(message));
          }
        });

        // Check for existing auth and handle callback
        checkStoredAuth();
        handleSpotifyCallback();

        console.log("App initialized successfully");
      }

      // Initialize when DOM is ready
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initializeApp);
      } else {
        initializeApp();
      }
    </script>
  </body>
</html>
